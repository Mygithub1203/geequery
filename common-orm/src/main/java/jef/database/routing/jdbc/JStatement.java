package jef.database.routing.jdbc;

import java.io.StringReader;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;
import java.util.LinkedList;
import java.util.List;

import jef.database.DbUtils;
import jef.database.OperateTarget;
import jef.database.RoutingSQLExecutor;
import jef.database.innerpool.JConnection;
import jef.database.jsqlparser.parser.ParseException;
import jef.database.jsqlparser.parser.StSqlParser;
import jef.database.wrapper.result.JdbcResultSetAdapter;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@SuppressWarnings("unchecked")
public class JStatement implements java.sql.Statement {
	private static final Logger log = LoggerFactory.getLogger(JStatement.class);

	private JConnection conn;

	/**
	 * 经过计算后的结果集，允许使用 getResult函数调用.
	 * 
	 * 一个statement只允许有一个结果集
	 */
	protected JdbcResultSetAdapter resultSet;
	/**
	 * 貌似是只有存储过程中会出现多结果集 因此不支持
	 */
	protected boolean moreResults;
	/**
	 * 更新计数，如果执行了多次，那么这个值只会返回最后一次执行的结果。 如果是一个query，那么返回的数据应该是-1
	 */
	protected int updateCount;
	/**
	 * 判断当前statment 是否是关闭的
	 */
	protected boolean closed;
	/**
	 * 
	 */
	private int resultSetType = -1;
	/**
	 * 
	 */
	private int resultSetConcurrency = -1;
	/**
	 * 
	 */
	private int resultSetHoldability = -1;
	/**
	 * 超时时间
	 */
	protected int queryTimeout = 0;
	/**
	 * 最大结果限制
	 */
	protected int maxRows = 0;
	/**
	 * 获取批大小
	 */
	protected int fetchSize = 0;

	protected List<String> batchedArgs;

	public 	JStatement(JConnection routingConnection){
		this.conn = routingConnection;
	}
	
	public JStatement(JConnection routingConnection, int resultsetType, int resultSetConcurrency, int resultSetHoldability) {
		this.conn = routingConnection;
		this.resultSetType = resultsetType;
		this.resultSetConcurrency = resultSetConcurrency;
		this.resultSetHoldability = resultSetHoldability;
	}

	public int executeUpdate(String sql) throws SQLException {
		return executeUpdateInternal(sql, -1, null, null,null);
	}

	public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
		return executeUpdateInternal(sql, autoGeneratedKeys, null, null,null);
	}

	public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
		return executeUpdateInternal(sql, -1, columnIndexes, null,null);
	}

	public int executeUpdate(String sql, String[] columnNames) throws SQLException {
		return executeUpdateInternal(sql, -1, null, columnNames,null);
	}

	public void closeInterval() throws SQLException {
		if (closed) {
			return;
		}
		closed = true;
		if(resultSet!=null){
			DbUtils.close(resultSet);
		}
	}

	protected int executeUpdateInternal(String sql, int autoGeneratedKeys, int[] columnIndexes, String[] columnNames, List<Object> params) throws SQLException {
		jef.database.jsqlparser.visitor.Statement st = parse(sql);
		SQLExecutor se;
		if (st == null) { //无法解析，直接运行
			se=new SimpleSQLExecutor((OperateTarget) conn.get().getSqlTemplate(null),sql);
		}else{
			se=new RoutingSQLExecutor(conn.get(),st);
		}
		se.setFetchSize(this.fetchSize);
		se.setMaxResults(this.maxRows);
		if(resultSetType>0)
			se.setResultSetType(resultSetType);
		if(resultSetConcurrency>0)
			se.setResultSetConcurrency(resultSetConcurrency);
		if(resultSetHoldability>0)
			se.setResultSetHoldability(resultSetHoldability);
		if(queryTimeout>0)
			se.setQueryTimeout(queryTimeout);
		if(params!=null)
			se.setParams(params);
		return se.executeUpdate();
		
	}

	private Statement createStatementInternal(Connection connection) throws SQLException {
		Statement stmt;
		if (this.resultSetType != -1 && this.resultSetConcurrency != -1 && this.resultSetHoldability != -1) {
			stmt = connection.createStatement(this.resultSetType, this.resultSetConcurrency, this.resultSetHoldability);
		} else if (this.resultSetType != -1 && this.resultSetConcurrency != -1) {
			stmt = connection.createStatement(this.resultSetType, this.resultSetConcurrency);
		} else {
			stmt = connection.createStatement();
		}
		return stmt;
	}

	private boolean executeInternal(String sql, int autoGeneratedKeys, int[] columnIndexes, String[] columnNames) throws SQLException {
		if (SqlTypeParser.isQuerySql(sql)) {
			executeQuery(sql);
			return true;
		} else {
			if (autoGeneratedKeys == -1 && columnIndexes == null && columnNames == null) {
				executeUpdate(sql);
			} else if (autoGeneratedKeys != -1) {
				executeUpdate(sql, autoGeneratedKeys);
			} else if (columnIndexes != null) {
				executeUpdate(sql, columnIndexes);
			} else if (columnNames != null) {
				executeUpdate(sql, columnNames);
			} else {
				executeUpdate(sql);
			}
			return false;
		}
	}

	public boolean execute(String sql) throws SQLException {
		return executeInternal(sql, -1, null, null);
	}

	public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
		return executeInternal(sql, autoGeneratedKeys, null, null);
	}

	public boolean execute(String sql, int[] columnIndexes) throws SQLException {
		return executeInternal(sql, -1, columnIndexes, null);
	}

	public boolean execute(String sql, String[] columnNames) throws SQLException {
		return executeInternal(sql, -1, null, columnNames);
	}

	public void addBatch(String sql) throws SQLException {
		checkClosed();
		if (batchedArgs == null) {
			batchedArgs = new LinkedList<String>();
		}
		if (sql != null) {
			batchedArgs.add(sql);
		}
	}

	public void clearBatch() throws SQLException {
		checkClosed();
		if (batchedArgs != null) {
			batchedArgs.clear();
		}
	}

	public void close() throws SQLException {
		if(this.closed){
			return;
		}
		closed=true;
//		if(this.)
	}

	// public int[] executeBatch() throws SQLException {
	// checkClosed();
	// ensureResultSetIsEmpty();
	// // 这个地方等到执行计划出来之后，发现确实有跨库的事务再予以拒绝。
	// // if (!connectionManager.getAutoCommit()) {
	// // throw new SQLException("executeBatch暂不支持事务");
	// // }
	// if (batchedArgs == null || batchedArgs.isEmpty()) {
	// return new int[0];
	// }
	//
	// List<SQLException> exceptions = new ArrayList<SQLException>();
	// List<Integer> result = new ArrayList<Integer>();
	// Map<String/* 数据源ID */, List<String/* 数据源上执行的SQL */>> sqls = null;
	// try {
	// DirectlyRouteCondition ruleCondition = (DirectlyRouteCondition)
	// getRouteContiongFromThreadLocal(ThreadLocalString.RULE_SELECTOR);
	//
	// // if (directlyRouteCondition != null) {
	// // // 是直接路由的condition
	// // String dbRuleId = directlyRouteCondition.getDbRuleID();
	// // if (connectionManager.containDBIndex(dbRuleId)) {
	// // // 这里是直接执行sql
	// // throw new SQLException("batch not support");
	// // } else {
	// // // 不包含目标id
	// // // 那么判断一下当前rc里面是否有需要替换的表名，如果有需要替换的
	// // // 表名，则抛出异常，目标数据库未找到，如果没有要替换的表名。则走规则选择
	// // if
	// // (directlyRouteCondition.getShardTableMap().get(dbRuleId).isEmpty())
	// // {
	// // sqls = sortBatch(batchedArgs, dbRuleId);
	// // } else {
	// // throw new SQLException("can't find target db : "
	// // + dbRuleId);
	// // }
	// // }
	//
	// if (ruleCondition != null) {
	// String dbRuleId = ruleCondition.getDbRuleID();
	// sqls = sortBatch(batchedArgs, dbRuleId);
	// } else {
	// sqls = sortBatch(batchedArgs, null);
	// }
	// // add by jiechen.qzm batch不支持跨库事务
	// if (sqls.size() > 1 && !connectionManager.getAutoCommit()) {
	// throw new SQLException("executeBatch暂不支持跨库事务，该事务涉及 "
	// + sqls.size() + " 个库。");
	// }
	//
	// for (Entry<String, List<String>> entry : sqls.entrySet()) {
	// String dbSelectorID = entry.getKey();
	// List<Integer> list = null;
	// try {
	// // 这里显示的使用go slave为false
	// // 拉屎关门
	// Connection conn = connectionManager.getConnection(
	// dbSelectorID, false);
	// try {
	// list = executeBatchOnOneConnAndCloseStatement(
	// exceptions, entry.getValue(), conn);
	// result.addAll(list);
	// } finally {
	// exceptions = tryCloseConnection(exceptions,
	// dbSelectorID);
	// }
	// } catch (SQLException e) {
	// exceptions = appendToExceptionList(exceptions, e);
	// }
	// }
	// } finally {
	// batchedArgs.clear();
	// }
	// currentResultSet = null;
	// moreResults = false;
	// updateCount = 0;
	// ExceptionUtils.throwSQLException(exceptions, "batch",
	// Collections.EMPTY_MAP);
	//
	// return fromListToArray(result);
	// // return new int[0];
	// }
	//
	// public Map<String, List<String>> sortBatch(List<String> sql,
	// String selectKey) throws SQLException {
	// Map<String, List<String>> targetSqls = new HashMap<String, List<String>>(
	// 8);
	// StartInfo startInfo = new StartInfo();
	// for (String originalSql : sql) {
	// startInfo.setSql(originalSql);
	// startInfo
	// .setSqlType(SqlTypeParser.getSqlType(originalSql));
	// bootstrap
	// .bootstrapForBatch(startInfo, false, targetSqls, selectKey);
	// }
	// return targetSqls;
	// }
	//
	// public Map<String, Map<String, List<List<ParameterContext>>>>
	// sortPreparedBatch(
	// String sql, List<Map<Integer, ParameterContext>> batchedParameters,
	// String selectKey) throws SQLException {
	// Map<String, Map<String, List<List<ParameterContext>>>> targetSqls = new
	// HashMap<String, Map<String, List<List<ParameterContext>>>>(
	// 16);
	// StartInfo startInfo = new StartInfo();
	// startInfo.setSql(sql);
	// startInfo.setSqlType(SqlTypeParser.getSqlType(sql));
	// for (Map<Integer, ParameterContext> map : batchedParameters) {
	// startInfo.setSqlParam(map);
	// bootstrap.bootstrapForPrepareBatch(startInfo, false, targetSqls,
	// selectKey);
	// }
	// return targetSqls;
	// }
	//
	// /**
	// * 这个方法先被注释掉，因为无法返回 batch的结果，只有SqlException是不够的。
	// *
	// * @param exceptions
	// * @param sqls
	// * @param conn
	// * @return
	// */
	// /*
	// * protected List<SQLException> executeBatchOnOneConnAndCloseStatement(
	// * List<SQLException> exceptions, List<String> sqls, Connection conn) {
	// try
	// * { Statement stmt = createStatementInternal(conn);
	// *
	// * try { try { for (String targetSql : sqls) { stmt.addBatch(targetSql); }
	// * stmt.executeBatch(); } catch (SQLException e) { exceptions =
	// * appendToExceptionList(exceptions, e); } stmt.clearBatch(); } finally {
	// * stmt.close(); } } catch (SQLException e) { exceptions =
	// * appendToExceptionList(exceptions, e); } return exceptions; }
	// */
	//
	// /**
	// * 返回影响数量的list,多条sql的话直接append
	// *
	// * @param exceptions
	// * @param sqls
	// * @param conn
	// * @return
	// */
	// protected List<Integer> executeBatchOnOneConnAndCloseStatement(
	// List<SQLException> exceptions, List<String> sqls, Connection conn) {
	// List<Integer> result = new ArrayList<Integer>();
	// try {
	// Statement stmt = createStatementInternal(conn);
	// try {
	// try {
	// int[] temp = null;
	// for (String targetSql : sqls) {
	// stmt.addBatch(targetSql);
	// }
	// temp = stmt.executeBatch();
	// result.addAll(fromArrayToList(temp));
	// } catch (SQLException e) {
	// exceptions = appendToExceptionList(exceptions, e);
	// }
	// stmt.clearBatch();
	// } finally {
	// stmt.close();
	// }
	// } catch (SQLException e) {
	// exceptions = appendToExceptionList(exceptions, e);
	// }
	// return result;
	// }
	//
	// /**
	// * 从 int[] 到 List<Integer> 的准换
	// *
	// * @param array
	// * @return
	// */
	// public static List<Integer> fromArrayToList(int[] array) {
	// if (array == null) {
	// return null;
	// }
	// List<Integer> result = new ArrayList<Integer>();
	// for (int num : array) {
	// result.add(num);
	// }
	// return result;
	// }
	//
	// /**
	// * 从 List<Integer> 到 int[] 的准换
	// *
	// * @param list
	// * @return
	// */
	// public static int[] fromListToArray(List<Integer> list) {
	// if (list == null) {
	// return null;
	// }
	// int[] result = new int[list.size()];
	// for (int i = 0; i < list.size(); i++) {
	// result[i] = list.get(i);
	// }
	// return result;
	// }
	//
	protected void checkClosed() throws SQLException {
		if (closed) {
			throw new SQLException("No operations allowed after statement closed.");
		}
	}

	// /**
	// * 如果新建了查询，那么上一次查询的结果集应该被显示的关闭掉。这才是符合jdbc规范的
	// *
	// * @throws SQLException
	// */
	// protected void ensureResultSetIsEmpty() throws SQLException {
	// if (currentResultSet != null) {
	// log.debug("result set is not null,close current result set");
	// try {
	// currentResultSet.close();
	// } catch (SQLException e) {
	// log.error("exception on close last result set . can do nothing..", e);
	// } finally {
	// // 最终要显示的关闭它
	// currentResultSet = null;
	// }
	// }
	// }
	//
	// protected ResultSet executeQueryInternal(String sql, Map<Integer,
	// ParameterContext> originalParameterSettings, SqlType sqlType,
	// TStatementImp tStatementImp) throws SQLException {
	// checkClosed();
	// ensureResultSetIsEmpty();
	// ExecutionPlan context = null;
	// context = buildSqlExecutionContextUsePipeline(sql,
	// originalParameterSettings, sqlType);
	// fillMetaData(context.getSqlMetaData());
	//
	// /*
	// * modified by shenxun: 这里主要是处理mappingRule返回空的情况下，应该返回空结果集
	// */
	// if (context.mappingRuleReturnNullValue()) {
	// this.currentResultSet = getEmptyResultSet(this);
	// return currentResultSet;
	// }
	// // int tablesSize = 0;
	// dumpSql(sql, context.getSqlMap(), originalParameterSettings);
	//
	// // beforeSqlExecute();
	//
	// DummyTResultSet result = null;
	// // 这里允许抛出异常，有异常表示查尽结果集仍没有一个可返回的
	// result = mergeResultSets(this, connectionManager, context);
	//
	// this.currentResultSet = result;
	// this.moreResults = false;
	// this.updateCount = -1;
	// // 记录打开的resultSet,用于一起关闭时能找得到
	//
	// // afterSqlExecute();
	// if (connectionManager.getAutoCommit()) {
	// this.context.reset();
	// }
	// return result;
	// }
	//
	// public ResultSet executeQuery(String sql) throws SQLException {
	// SqlType sqlType = SqlTypeParser.getSqlType(sql);
	// return executeQueryInternal(sql, null, sqlType, this);
	// }
	//
	// // TODO : 使用策略模式进行合并，以支持并发查询和非并发查询
	// protected DummyTResultSet mergeResultSets(TStatementImp tStatementImp,
	// ConnectionManager connectionManager, ExecutionPlan context) throws
	// SQLException {
	//
	// if (context.getOrderByColumns() != null &&
	// !context.getOrderByColumns().isEmpty() && context.getGroupFunctionType()
	// != GroupFunctionType.NORMAL) {
	// throw new
	// SQLException("'group function' and 'order by' can't be together!");
	// }
	// // 如果是有切仅有一个数据源，并且只查一个表，那么走最简单的模式！
	// /*
	// * 简单模式就是直接去数据库执行，什么都不做，这种模式下可以支持任何查询，不需要合并，不需要
	// * 搞其他事情。就是去数据库查询，然后记下statement记下resultSet.即可，所有操作 直接通过结果集进行。不需要做额外判断。
	// */
	// if (ExecutionPlanUtils.isOneSqlPlan(context)) {
	// return new ShallowTResultSetWrapper(tStatementImp, connectionManager,
	// context);
	// }
	//
	// RealSqlExecutor rse = new RealSqlExecutorImp(parallelRealSqlExecutor,
	// serialRealSqlExecutor, tStatementImp, context);
	//
	// // 如果是ave那么不能支持
	// if (context.getGroupFunctionType() == GroupFunctionType.AVG) {
	// throw new SQLException("The group function 'AVG' is not supported now!");
	// } else if (context.getGroupFunctionType() == GroupFunctionType.COUNT) {
	// // 如果是count则进行合并
	// return new CountTResultSet(tStatementImp, connectionManager, context,
	// rse);
	// } else if (context.getGroupFunctionType() == GroupFunctionType.MAX) {
	// // 如果是
	// return new MaxTResultSet(tStatementImp, connectionManager, context, rse);
	// } else if (context.getGroupFunctionType() == GroupFunctionType.MIN) {
	// return new MinTResultSet(tStatementImp, connectionManager, context, rse);
	// } else if (context.getGroupFunctionType() == GroupFunctionType.SUM) {
	// return new SumTResultSet(tStatementImp, connectionManager, context, rse);
	// } else if (context.getDistinctColumns() != null &&
	// context.getDistinctColumns().size() != 0) {
	// // 此时肯定已经是单库多表或者多库多表case了,
	// DistinctTResultSet rs = new DistinctTResultSet(tStatementImp,
	// connectionManager, context, rse);
	// rs.setDistinctColumn(context.getDistinctColumns());
	// return rs;
	// } else if (context.getOrderByColumns() != null &&
	// !context.getOrderByColumns().isEmpty()) {
	// OrderByColumn[] orderByColumns = new
	// OrderByColumn[context.getOrderByColumns().size()];
	// int i = 0;
	// for (OrderByEle element : context.getOrderByColumns()) {
	// orderByColumns[i] = new OrderByColumn();
	// orderByColumns[i].setColumnName(element.getName());
	// orderByColumns[i++].setAsc(element.isASC());
	// }
	// OrderByTResultSet orderByTResultSet = new
	// OrderByTResultSet(tStatementImp, connectionManager, context, rse);
	// orderByTResultSet.setOrderByColumns(orderByColumns);
	// orderByTResultSet.setLimitFrom(context.getSkip());
	// orderByTResultSet.setLimitTo(context.getMax());
	// return orderByTResultSet;
	// } else {
	// /**
	// * 这个有点特殊
	// */
	// RealSqlExecutor spe = new
	// SimpleRealSqlExecutorImp(parallelRealSqlExecutor,
	// simpleSerialRealSqlExecutor, tStatementImp, context);
	// SimpleTResultSet simpleTResultSet = new SimpleTResultSet(tStatementImp,
	// connectionManager, context, spe);
	// simpleTResultSet.setLimitFrom(context.getSkip());
	// simpleTResultSet.setLimitTo(context.getMax());
	// return simpleTResultSet;
	// }
	// // 暂时排除走多库多表的GroupBy,Having,Distinct
	// }
	//
	// protected void beforeSqlExecute() throws SQLException {
	// if (connectionManager.getAutoCommit()) {
	// hookPoints.getBeforeExecute().execute(context);
	// }
	// }

	public Connection getConnection() throws SQLException {
		return conn;
	}

	// private ExecutionPlan buildSqlExecutionContextUsePipeline(String sql,
	// Map<Integer, ParameterContext> originalParameterSettings, SqlType
	// sqlType) throws SQLException {
	// StartInfo startInfo = new StartInfo();
	// startInfo.setSql(sql);
	// startInfo.setSqlType(sqlType);
	// startInfo.setSqlParam(originalParameterSettings);
	// return this.bootstrap.bootstrap(startInfo);
	// }

	/**
	 * 以下为不支持的方法
	 */
	public int getFetchDirection() throws SQLException {
		throw new UnsupportedOperationException("getFetchDirection");
	}

	public int getFetchSize() throws SQLException {
		return this.fetchSize;
	}

	public int getMaxFieldSize() throws SQLException {
		throw new UnsupportedOperationException("getMaxFieldSize");
	}

	public int getMaxRows() throws SQLException {
		return this.maxRows;
	}

	public boolean getMoreResults() throws SQLException {
		return moreResults;
	}

	public int getQueryTimeout() throws SQLException {
		return queryTimeout;
	}

	public void setQueryTimeout(int queryTimeout) throws SQLException {
		this.queryTimeout = queryTimeout;
	}

	public void setCursorName(String cursorName) throws SQLException {
		throw new UnsupportedOperationException("setCursorName");
	}

	public void setEscapeProcessing(boolean escapeProcessing) throws SQLException {
		throw new UnsupportedOperationException("setEscapeProcessing");
	}

	public SQLWarning getWarnings() throws SQLException {
		return null;
	}

	public void clearWarnings() throws SQLException {
	}

	public boolean getMoreResults(int current) throws SQLException {
		throw new UnsupportedOperationException("getMoreResults");
	}

	public ResultSet getResultSet() throws SQLException {
		return resultSet;
	}

	public int getResultSetConcurrency() throws SQLException {
		return resultSetConcurrency;
	}

	public int getResultSetHoldability() throws SQLException {
		return resultSetHoldability;
	}

	public int getResultSetType() throws SQLException {
		return resultSetType;
	}

	public int getUpdateCount() throws SQLException {
		return updateCount;
	}

	public void setFetchDirection(int fetchDirection) throws SQLException {
		throw new UnsupportedOperationException("setFetchDirection");
	}

	public void setFetchSize(int fetchSize) throws SQLException {
		this.fetchSize = fetchSize;
	}

	public void setMaxFieldSize(int maxFieldSize) throws SQLException {
		throw new UnsupportedOperationException("setMaxFieldSize");
	}

	public void setMaxRows(int maxRows) throws SQLException {
		this.maxRows = maxRows;
	}

	public ResultSet getGeneratedKeys() throws SQLException {
		throw new UnsupportedOperationException("getGeneratedKeys");
	}

	public void cancel() throws SQLException {
		throw new UnsupportedOperationException("cancel");
	}

	public int getQueryTimeOut() {
		return queryTimeout;
	}

	public void setResultSetType(int resultSetType) {
		this.resultSetType = resultSetType;
	}

	public void setResultSetConcurrency(int resultSetConcurrency) {
		this.resultSetConcurrency = resultSetConcurrency;
	}

	public void setResultSetHoldability(int resultSetHoldability) {
		this.resultSetHoldability = resultSetHoldability;
	}

	public boolean isWrapperFor(Class<?> iface) throws SQLException {
		return this.getClass().isAssignableFrom(iface);
	}

	public <T> T unwrap(Class<T> iface) throws SQLException {
		try {
			return (T) this;
		} catch (Exception e) {
			throw new SQLException(e);
		}
	}

	public boolean isClosed() throws SQLException {
		return closed;
	}

	public void setPoolable(boolean poolable) throws SQLException {
		throw new SQLException("not support exception");
	}

	public boolean isPoolable() throws SQLException {
		throw new SQLException("not support exception");
	}

	// protected ResultSet executeQueryInternal(String sql, Map<Integer,
	// ParameterContext> originalParameterSettings, SqlType sqlType,
	// TStatementImp tStatementImp) throws SQLException {
	// checkClosed();
	// ensureResultSetIsEmpty();
	// ExecutionPlan context = null;
	// context = buildSqlExecutionContextUsePipeline(sql,
	// originalParameterSettings, sqlType);
	// fillMetaData(context.getSqlMetaData());
	//
	// /*
	// * modified by shenxun: 这里主要是处理mappingRule返回空的情况下，应该返回空结果集
	// */
	// if (context.mappingRuleReturnNullValue()) {
	// this.currentResultSet = getEmptyResultSet(this);
	// return currentResultSet;
	// }
	// // int tablesSize = 0;
	// dumpSql(sql, context.getSqlMap(), originalParameterSettings);
	//
	// // beforeSqlExecute();
	//
	// DummyTResultSet result = null;
	// // 这里允许抛出异常，有异常表示查尽结果集仍没有一个可返回的
	// result = mergeResultSets(this, connectionManager, context);
	//
	// this.currentResultSet = result;
	// this.moreResults = false;
	// this.updateCount = -1;
	// // 记录打开的resultSet,用于一起关闭时能找得到
	//
	// // afterSqlExecute();
	// if (connectionManager.getAutoCommit()) {
	// this.context.reset();
	// }
	// return result;
	// }

	public ResultSet executeQuery(String sql) throws SQLException {
		jef.database.jsqlparser.visitor.Statement st = parse(sql);
		SQLExecutor jq;
		if (st == null) {
			jq=new SimpleSQLExecutor((OperateTarget) conn.get().getSqlTemplate(null),sql);
		}else{
			jq=new RoutingSQLExecutor(conn.get(),st);
		}
		jq.setFetchSize(this.fetchSize);
		jq.setMaxResults(this.maxRows);
		if(resultSetType>0)
			jq.setResultSetType(resultSetType);
		if(resultSetConcurrency>0)
			jq.setResultSetConcurrency(resultSetConcurrency);
		if(resultSetHoldability>0)
			jq.setResultSetHoldability(resultSetHoldability);
		if(queryTimeout>0)
			jq.setQueryTimeout(queryTimeout);
		return jq.getResultSet();
	}

	private jef.database.jsqlparser.visitor.Statement parse(String sql) {
		StSqlParser parser = new StSqlParser(new StringReader(sql));
		try {
			return parser.Statement();
		} catch (ParseException e) {
			log.error("Parse Error: {}", sql);
			return null;
		}
	}

	public int[] executeBatch() throws SQLException {
		return null;
	}

	/**
	 * 如果新建了查询，那么上一次查询的结果集应该被显示的关闭掉。这才是符合jdbc规范的
	 * 
	 * @throws SQLException
	 */
	protected void ensureResultSetIsEmpty() throws SQLException {
		if (resultSet != null) {
			log.debug("result set is not null,close current result set");
			try {
				resultSet.close();
			} catch (SQLException e) {
				log.error("exception on close last result set . can do nothing..", e);
			} finally {
				// 最终要显示的关闭它
				resultSet = null;
			}
		}
	}
}
