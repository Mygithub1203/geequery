package jef.database;

import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Savepoint;
import java.sql.Statement;
import java.util.Collection;

import javax.persistence.PersistenceException;

import jef.database.cache.CacheDummy;
import jef.database.cache.TransactionCache;
import jef.database.dialect.DatabaseDialect;
import jef.database.innerpool.IUserManagedPool;
import jef.database.innerpool.PartitionSupport;
import jef.database.innerpool.ReentrantConnection;
import jef.database.innerpool.Savepoints;
import jef.database.meta.ITableMetadata;
import jef.database.meta.MetaHolder;
import jef.database.support.DbOperatorListener;
import jef.tools.StringUtils;

public class ConnectionManagedSession extends Session implements TransactionStatus{
	private DbClient parent;
	private Conn conn;
	private String parentName;// 当关闭后parent即为null，此时需要使用该变量显示日志
	
	public ConnectionManagedSession(DbClient parent,Connection connection) {
		super();
		this.parent = parent;
		rProcessor = parent.rProcessor;
		selectp = parent.selectp;
		p = parent.p;
		insertp = parent.insertp;
		batchinsertp = parent.batchinsertp;
		this.conn=new Conn(connection);
	}
	static class Conn implements ReentrantConnection{
		private Connection conn;
		public Conn(Connection conn2) {
			this.conn=conn2;
		}

		@Override
		public void closePhysical() {
			try {
				conn.close();
			} catch (SQLException e) {
				throw new PersistenceException(e);
			}
		}

		@Override
		public void setKey(String key) {
		}

		@Override
		public boolean isUsed() {
			return true;
		}

		@Override
		public Savepoints setSavepoints(String savepointName) throws SQLException {
			return new Savepoints(savepointName,conn);
		}

		@Override
		public void ensureOpen() throws SQLException {
		}

		@Override
		public void setAutoCommit(boolean autoCommit) throws SQLException {
			conn.setAutoCommit(autoCommit);
			
		}

		@Override
		public void commit() throws SQLException {
			conn.commit();
		}

		@Override
		public void rollback() throws SQLException {
			conn.rollback();
		}

		@Override
		public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
			return conn.createStatement(resultSetType, resultSetConcurrency);
		}

		@Override
		public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
			return conn.prepareStatement(sql, autoGeneratedKeys);
		}

		@Override
		public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
			return conn.prepareStatement(sql, resultSetType, resultSetConcurrency);
		}

		@Override
		public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHolder) throws SQLException {
			return conn.prepareStatement(sql, resultSetType, resultSetConcurrency,resultSetHolder);
		}

		@Override
		public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
			return conn.prepareStatement(sql, columnNames);
		}

		@Override
		public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
			return conn.prepareStatement(sql, columnIndexes);
		}

		@Override
		public Statement createStatement() throws SQLException {
			return conn.createStatement();
		}

		@Override
		public PreparedStatement prepareStatement(String sql) throws SQLException {
			return conn.prepareStatement(sql);
		}

		@Override
		public CallableStatement prepareCall(String sql) throws SQLException {
			return conn.prepareCall(sql);
		}

		@Override
		public DatabaseMetaData getMetaData() throws SQLException {
			return conn.getMetaData();
		}

		@Override
		public void setReadOnly(boolean readOnly) throws SQLException {
			conn.setReadOnly(readOnly);
		}

		@Override
		public int getTransactionIsolation() throws SQLException {
			return conn.getTransactionIsolation();
		}

		@Override
		public void setTransactionIsolation(int level) throws SQLException {
			conn.setTransactionIsolation(level);
		}

		@Override
		public void setUsedByObject(Object user) {
		}

		@Override
		public void addUsedByObject() {
		}

		@Override
		public Object popUsedByObject() {
			return null;
		}

		@Override
		public String toString() {
			return conn.toString();
		}
	}

	@Override
	public DatabaseDialect getProfile(String key) {
		ensureOpen();
		return parent.getProfile(key);	
	}

	private void ensureOpen() {
		if(conn==null){
			throw new IllegalStateException("The session was closed");
		}
	}

	@Override
	IUserManagedPool getPool() {
		return null;
	}

	@Override
	ReentrantConnection getConnection() throws SQLException {
		return conn;
	}

	@Override
	void releaseConnection(ReentrantConnection conn) {
		// DO nothing.
	}

	@Override
	protected String getDbName(String dbKey) {
		return parent == null ? this.parentName : parent.getDbName(dbKey);
	}

	@Override
	protected TransactionCache getCache() {
		return CacheDummy.getInstance();
	}

	@Override
	protected DbOperatorListener getListener() {
		return parent.getListener();
	}

	@Override
	protected String getTransactionId(String dbKey) {
		StringBuilder sb = new StringBuilder();
		sb.append("[Session");
		sb.append(StringUtils.toFixLengthString(this.hashCode(), 8)).append('@');
		sb.append(parent != null ? parent.getDbName(dbKey) : parentName);
		sb.append('@').append(Thread.currentThread().getId()).append(']');
		return sb.toString();
	}

	@Override
	protected Collection<String> getAllDatasourceNames() {
		return parent.getAllDatasourceNames();
	}

	@Override
	protected OperateTarget asOperateTarget(String dbKey) {
		if (StringUtils.isEmpty(dbKey))
			return new OperateTarget(this, null);
		return new OperateTarget(this,dbKey);
	}

	@Override
	public void close() {
	}

	@Override
	public boolean isOpen() {
		return true;
	}

	@Override
	public <T> NativeQuery<T> createNamedQuery(String name, Class<T> resultWrapper) {
		if (parent.namedQueries == null)
			parent.initNQ();
		NQEntry nc = parent.namedQueries.get(name);
		if (nc == null)
			return null;
		return asOperateTarget(MetaHolder.getMappingSite(nc.getTag())).createNativeQuery(nc, resultWrapper);
	}

	@Override
	public <T> NativeQuery<T> createNamedQuery(String name, ITableMetadata resultMeta) {
		if (parent.namedQueries == null)
			parent.initNQ();
		NQEntry nc = parent.namedQueries.get(name);
		if (nc == null)
			return null;
		return asOperateTarget(MetaHolder.getMappingSite(nc.getTag())).createNativeQuery(nc, resultMeta);
	}

	@Override
	public DbClient getNoTransactionSession() {
		return parent;
	}

	@Override
	PartitionSupport getPartitionSupport() {
		return parent.getPartitionSupport();
	}

	@Override
	public void commit(boolean flag) {
		
	}

	@Override
	public void rollback(boolean flag) {
	}

	@Override
	public void setRollbackOnly(boolean b) {
	}

	@Override
	public boolean isRollbackOnly() {
		return false;
	}

	@Override
	public Savepoint setSavepoint(String savepointName) throws SQLException {
		return conn.setSavepoints(savepointName);
	}

	@Override
	public void rollbackToSavepoint(Savepoint savepoint) throws SQLException {
		((Savepoints)savepoint).rollbackSavepoints();
	}

	@Override
	public void releaseSavepoint(Savepoint savepoint) {
		try {
			((Savepoints)savepoint).releaseSavepoints();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}
}
