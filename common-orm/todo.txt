============== 确定已经解决的问题 ==============
dubbo客户端能否指定URL? (Fixed, OK)
CXF-PLUS重构，补充测试案例，用法变化。(OK)
CXF下发现如将Object注册为JSON转换器，则List等Collection的反序列化数据会丢失，暂时关闭此功能(OK)
同维度下的映射关系分表+分库。。。。设计分析，是否需要改造（分析，暂无需改造，分表规则加载器可以支持）
RoutingConnection连接提交状态错误引起死锁（OK）
启动时metadata及其连接池可能被初始化2次的问题。(OK)
分表时，自增值生成提前，使其能作为分表参数所利用。分表时对于primitive值的有效性判断增强。(OK)
增加MAPPING函数等，简化分库分表规则配置。(OK)
支持按需建表(OK)
修复了ADV TABLE模式下自增生成的若干小错误。
缩小首次建表范围（OK），引发若干测试错误，采用表过滤机制解决。(OK)
不启用按需建表后，需要保留全范围或大范围建表功能（通过DateSpan可配置解决，OK）
修复关于使用FBIField造成单表更新和删除操作尝试绑定Query时空指针异常(OK)
分库分表聚合等支持、对分表分库后混合结果集进行支持（聚合、排序、distinct）OK
============== 基本上解决的问题 ==============
CXF 2.7.10提高了兼容性，但是CXF-Plus的ASM类产生的package-info不兼容 (无法重现，修订CXF-PLUS中的引用，怀疑还是和包冲突有关，修订，暂时算OK)
对启用表过滤机制后，造成无表输出后的查询返回空结果集场景进行支持和测试(应该OK 测试了一下增加案例，似乎无问题，待下次回归时检测)
的分表结果返回错误问题（返回无表）


================ 待解决的问题  ===================
基于SQL分析的分库分表、对NativeQuery支持的分表分库操作
为大部分测试案例增加断言
—Batch Insert等操作下的极限性能模式。(不返回值、性能分析等手段)、此外对于Batch可能需要统计并输出因为Sequence而消耗的时间，Oracle下的实现特殊优化 hint, no logging
——极限模式下：启用该数据库本身的特殊优化操作——no logging /*+APPEND */ 等。极限模式下不回写自增值等。

对照TDDL分库分表优势体现
http://10.22.33.106/index!controlIndex.action
MSSQL Server支持

Oracle/MSSQL分析函数支持

HSQLDB的函数对DATE还不支持。HSQLDB中还有很多函数没有写到方言中去（待完成 http://hsqldb.org/doc/2.0/guide/builtinfunctions-chapt.html） 


MySQL Sharding
Hibernate Shards
TDDL
   if not exists (select 1 from t where id = 1)
      insert into t(id, update_time) values(1, getdate())
   else
      update t set update_time = getdate() where id = 1
那么 MySQL 中如何实现这样的逻辑呢？别着急！MySQL 中有更简单的方法： replace into
replace into t(id, update_time) values(1, now());
或
replace into t(id, update_time) select 1, now();

它可以让一个Hibernate应用比较简单地加入横向分割的数据库分布式功能。另外，还有HiveDB。其底层也是基于Hibernate shards实现，目前版本相对稳定，
其亮点是具有类似mysql proxy之类多服务器容错功能，单独服务器发生故障不影响系统正常运行，通过类似ha-jdbc思想实现。
最后，不得不提的就是淘宝贡献的TDDL，使用过淘宝的同学应该都深有体会，其可靠性、可用性、稳定性、可扩展性均领跑业界很多同类产品。
TDDL最大的两个亮点是动态数据源管理和分库分表。建议抽出游戏时间，向淘宝好好学习，天天向上！ 



支持SQLServer 2008

读取Sequence initialValue=1000   allocationSize (OK)
读取Table initialValue=1000   valueColumnName   pkColumnValue table   allocationSize (OK)
Hilo实现和 DB_AUTOINCREMENT_HILO （OK）
DB_SEQUENCE_STEP 0和-1的两种不同检测方式(OK)
全局的SequenceTable表名可定义(OK)
AutoIncreatmentCallBack大量使用Property优化(OK)
UUID实现支持removeDash (OK)
hilo模式下的cacheSize可缩小或干脆为1(OK)
Table init value的校准等问题(OK)
PRIMARY KEY的匹配方式(OK)
filterCondition右侧对多加载时的排序和结果限制问题 (OK)
当一个对象中指向同个目标的JoinDescrption配置不同时，被当做是相同的关联查询进行处理。(OK)
AnnotationValueCompare的处理（OK JDK自身已经实现得很好）
当多对一时，fetch=LAZY现在可以生效(OK)
当filterCondition等辅助描述被区分为多种关联时，(OK)


JoinKey和JoinExpression重构
新场景支持，静态表关联到动态表
重构，关于vsMany和vsOne目前界限正在模糊，需要按照lazy和eager两种方式重新修改。


支持统一的to_date函数(待验证Hibernate做法) --PG Oracle支持，MYSQL不明 hibernate是否支持在MySQL上模拟？ 
filterCondition中出现的表达式中的函数的多数据库问题(待filtercondition重构实现)
关于filterCondition的出现的表达式认为匹配当前表还是匹配右侧表的问题（默认匹配右侧表）
实际上多对一时，可以填写仅匹配 左侧表的条件，但是当对多时，则必须是匹配右侧表. (以后逐渐完善)




